<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pipe Mania</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: #1a1a2e;
    color: #eee;
    font-family: 'Courier New', monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 20px;
    transition: background 0.6s;
  }
  h1 { font-size: 2rem; color: #f0a500; letter-spacing: 4px; margin-bottom: 10px; text-shadow: 0 0 20px #f0a500; }
  #hud { display: flex; gap: 24px; margin-bottom: 12px; font-size: 1rem; }
  #hud span { color: #aaa; }
  #hud strong { color: #f0a500; font-size: 1.2rem; }
  #lives-display { color: #e74c3c !important; letter-spacing: 3px; }
  #timer-bar-wrap { width: 738px; height: 12px; background: #333; border-radius: 6px; margin-bottom: 12px; overflow: hidden; }
  #timer-bar { height: 100%; background: linear-gradient(90deg, #27ae60, #f0a500, #e74c3c); width: 100%; transition: width 0.1s linear; border-radius: 6px; }
  #game-area { display: flex; gap: 16px; align-items: flex-start; }
  #queue-panel { display: flex; flex-direction: column; gap: 6px; background: #16213e; border: 2px solid #0f3460; border-radius: 8px; padding: 10px 8px; }
  #queue-panel h3 { font-size: 0.7rem; color: #888; text-align: center; letter-spacing: 2px; margin-bottom: 4px; }
  .queue-cell { width: 54px; height: 54px; background: #0f3460; border-radius: 4px; display: flex; align-items: center; justify-content: center; }
  .queue-cell.next { border: 2px solid #f0a500; background: #1a3a6e; }
  #grid { display: grid; grid-template-columns: repeat(10, 72px); grid-template-rows: repeat(8, 72px); gap: 2px; background: #0f3460; border: 3px solid #0f3460; border-radius: 4px; cursor: pointer; transition: background 0.6s, border-color 0.6s; }
  .cell { width: 72px; height: 72px; background: #16213e; position: relative; transition: background 0.1s; }
  .cell:hover { background: #1e2d5a; }
  .cell canvas { position: absolute; top: 0; left: 0; }
  #overlay { display: none; justify-content: center; margin-top: 16px; }
  #overlay.show { display: flex; }
  #overlay-box { background: #16213e; border: 3px solid #f0a500; border-radius: 12px; padding: 24px 40px; text-align: center; transition: border-color 0.3s; display: flex; align-items: center; gap: 32px; }
  #overlay-box h2 { font-size: 1.6rem; color: #f0a500; margin-bottom: 6px; transition: color 0.3s; }
  #overlay-box p { color: #ccc; margin-bottom: 4px; font-size: 1rem; }
  #overlay-box button { padding: 12px 28px; background: #f0a500; color: #1a1a2e; border: none; border-radius: 6px; font-size: 1rem; font-family: 'Courier New', monospace; font-weight: bold; cursor: pointer; letter-spacing: 2px; white-space: nowrap; flex-shrink: 0; }
  #overlay-box button:hover { filter: brightness(1.15); }
  #msg { height: 24px; font-size: 0.9rem; color: #f0a500; margin-top: 8px; letter-spacing: 1px; }

  /* compact in-game leaderboard */
  #leaderboard { font-size: 0.75rem; letter-spacing: 1px; min-width: 148px; }
  #lb-title { color: #666; font-size: 0.65rem; letter-spacing: 3px; margin-bottom: 6px; text-align: center; }
  .lb-row { display: flex; gap: 8px; padding: 2px 0; color: #888; }
  .lb-row.lb-hl { color: #f0a500; font-weight: bold; }
  .lb-rank { width: 14px; text-align: right; color: #555; }
  .lb-name { width: 26px; color: #ccc; }
  .lb-score { width: 40px; text-align: right; }
  .lb-lvl { color: #555; }

  /* title-screen leaderboard — arcade prominent style */
  #overlay-box.is-title { flex-direction: column; padding: 32px 48px; gap: 0; }
  #overlay-box.is-title > div:first-child { margin-bottom: 20px; }
  #overlay-box.is-title #leaderboard { font-size: 1rem; min-width: 300px; width: 100%; }
  #overlay-box.is-title #lb-title { font-size: 0.7rem; letter-spacing: 5px; color: #f0a500; margin-bottom: 10px; border-bottom: 1px solid #0f3460; padding-bottom: 8px; }
  #overlay-box.is-title .lb-row { padding: 5px 0; border-bottom: 1px solid #0d1f3a; justify-content: center; gap: 0; }
  #overlay-box.is-title .lb-row.lb-hl { background: rgba(240,165,0,0.07); }
  #overlay-box.is-title .lb-rank { width: 28px; font-size: 0.8rem; color: #444; }
  #overlay-box.is-title .lb-name { width: 52px; font-size: 1.1rem; color: #eee; letter-spacing: 4px; }
  #overlay-box.is-title .lb-score { width: 72px; font-size: 1.1rem; color: #f0a500; text-align: right; }
  #overlay-box.is-title .lb-lvl { width: 40px; text-align: right; font-size: 0.8rem; color: #556; padding-left: 8px; }
  #overlay-box.is-title button { margin-top: 24px; }
  #initials-section { display: none; align-items: center; gap: 8px; margin-top: 10px; font-size: 0.85rem; color: #aaa; letter-spacing: 1px; }
  #initials-input { background: #0f3460; color: #f0a500; border: 1px solid #f0a500; border-radius: 3px; font-family: 'Courier New', monospace; font-size: 1.1rem; text-transform: uppercase; letter-spacing: 6px; width: 68px; text-align: center; padding: 3px 6px; outline: none; }
  #initials-input:focus { border-color: #ffc107; box-shadow: 0 0 8px rgba(240,165,0,0.4); }
  #music-btn { background: none; border: 1px solid #444; color: #aaa; cursor: pointer; font-size: 1.1rem; padding: 2px 8px; border-radius: 4px; font-family: inherit; transition: color 0.2s, border-color 0.2s; line-height: 1.4; }
  #music-btn:hover { color: #f0a500; border-color: #f0a500; }
  #music-btn.muted { color: #444; border-color: #333; }
  #speedup-btn { background: none; border: 1px solid #27ae60; color: #27ae60; cursor: pointer; font-size: 0.85rem; padding: 2px 10px; border-radius: 4px; font-family: inherit; font-weight: bold; letter-spacing: 1px; transition: all 0.15s; line-height: 1.4; }
  #speedup-btn:hover:not(:disabled) { background: #27ae60; color: #1a1a2e; }
  #speedup-btn:disabled { color: #333; border-color: #333; cursor: default; }
</style>
</head>
<body>

<h1>PIPE MANIA</h1>
<div id="hud">
  <div><span>LVL </span><strong id="level-display">1</strong></div>
  <div><span>SCORE </span><strong id="score-display">0</strong></div>
  <div><span>BEST </span><strong id="best-display">0</strong></div>
  <div><span>LIVES </span><strong id="lives-display">♥♥♥</strong></div>
  <div><span>FLOW IN </span><strong id="countdown-display">10</strong></div>
  <div><button id="speedup-btn" title="Start flow now / speed up (Space)">▶▶ GO</button></div>
  <div><button id="music-btn" title="Toggle music">♪</button></div>
</div>
<div id="timer-bar-wrap"><div id="timer-bar"></div></div>

<div id="game-area">
  <div id="queue-panel"><h3>NEXT</h3></div>
  <div id="grid-wrap">
    <div id="grid"></div>
    <div id="msg"></div>
  </div>
</div>

<div id="overlay" class="show">
  <div id="overlay-box" class="is-title">
    <div>
      <h2 id="overlay-title">PIPE MANIA</h2>
      <p id="overlay-msg">Route water from the faucet to the target!</p>
      <p id="overlay-score" style="display:none"></p>
      <div id="initials-section">
        <span>INITIALS:</span>
        <input id="initials-input" maxlength="3" value="" spellcheck="false" autocomplete="off">
      </div>
    </div>
    <div id="leaderboard"></div>
    <button id="overlay-btn">PLAY</button>
  </div>
</div>

<script>
// ============================================================
// CONSTANTS
// ============================================================
const COLS = 10, ROWS = 8, CELL = 72, BW = 3, PW_RATIO = 0.34;

const PIPES = {
  SH:    { id:'SH',    conn:[0,0,1,1] },
  SV:    { id:'SV',    conn:[1,1,0,0] },
  CNE:   { id:'CNE',   conn:[1,0,1,0] },
  CNW:   { id:'CNW',   conn:[1,0,0,1] },
  CSE:   { id:'CSE',   conn:[0,1,1,0] },
  CSW:   { id:'CSW',   conn:[0,1,0,1] },
  CROSS: { id:'CROSS', conn:[1,1,1,1] },
  BONUS: { id:'BONUS', conn:[1,1,1,1] },
};

// Level color palettes — distinct theme per level, cycling after 7
const LEVEL_PALETTES = [
  { pipe:'#4a7fbf', pipeB:'#2a5090', water:'#27ae60', waterB:'#1a7a3a', grid:'#0f3460', bg:'#1a1a2e' },
  { pipe:'#8e44ad', pipeB:'#5b2c6f', water:'#e67e22', waterB:'#a04000', grid:'#3a1f5e', bg:'#1c1826' },
  { pipe:'#c0392b', pipeB:'#7b241c', water:'#2980b9', waterB:'#154360', grid:'#4e1f1f', bg:'#251515' },
  { pipe:'#16a085', pipeB:'#0e6655', water:'#f39c12', waterB:'#9a6400', grid:'#0e3d30', bg:'#142520' },
  { pipe:'#d35400', pipeB:'#873600', water:'#8e44ad', waterB:'#5b2c6f', grid:'#3d2010', bg:'#22180e' },
  { pipe:'#1e8bc3', pipeB:'#115573', water:'#e74c3c', waterB:'#7b241c', grid:'#112d46', bg:'#121820' },
  { pipe:'#27ae60', pipeB:'#1a7a3a', water:'#d35400', waterB:'#873600', grid:'#133d22', bg:'#12201a' },
];

// End tile colors stay constant (gold target)
const C_END = '#d4a010', C_END_B = '#7a5800';

const MAX_LIVES = 3;

// ============================================================
// STATE
// ============================================================
let level = 1, score = 0, lives = MAX_LIVES;
let best = parseInt(localStorage.getItem('pm_best') || '0');
let gameState = 'idle';
let grid = [], queue = [];
let startCell = null, endCell = null, bonusCell = null, flowPath = [];

let flowActive = false;
let currentFlowCell = null;
let flowProgress = 0, lastTime = null;
let animFrame = null, firstFlowTimeout = null;

let countdownTimer = null, countdownVal = 0, timerStart = null;

let faucetAnimTimer = null, faucetPulse = 0;
let currentLevelParams = null, flowSpeedMult = 1;

let overlayAction = 'new';
let pendingScore = null; // { score, level } — set before showOverlay when a score should be saved

// ============================================================
// HIGH SCORES
// ============================================================
function loadScores() {
  try { return JSON.parse(localStorage.getItem('pm_scores') || '[]'); } catch(e) { return []; }
}

function addHighScore(initials, s, lvl) {
  const scores = loadScores();
  const clean = (initials || '').toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 3).padEnd(3, '_');
  scores.push({ initials: clean, score: s, level: lvl });
  scores.sort((a, b) => b.score - a.score);
  scores.length = Math.min(scores.length, 10);
  localStorage.setItem('pm_scores', JSON.stringify(scores));
}

function qualifiesForBoard(s) {
  const sc = loadScores();
  return sc.length < 10 || s > sc[sc.length - 1].score;
}

function renderLeaderboard(highlightScore) {
  const lb = document.getElementById('leaderboard');
  const scores = loadScores();
  if (!scores.length) { lb.innerHTML = ''; return; }
  lb.innerHTML = '<div id="lb-title">HIGH SCORES</div>' +
    scores.map((e, i) => {
      const hl = highlightScore != null && e.score === highlightScore ? ' lb-hl' : '';
      return `<div class="lb-row${hl}"><span class="lb-rank">${i + 1}</span><span class="lb-name">${e.initials}</span><span class="lb-score">${e.score}</span><span class="lb-lvl">L${e.level}</span></div>`;
    }).join('');
}

// ============================================================
// LEVEL PARAMS
// ============================================================
function levelParams(lvl) {
  return {
    flowDelay:    Math.max(5000, 14000 - (lvl - 1) * 600),  // 14s → 5s floor
    flowInterval: Math.max(300,  2400  - (lvl - 1) * 120),  // 2.4s → 0.3s floor
    firstDelay:   3000,
  };
}

// ============================================================
// PALETTE
// ============================================================
function getPalette() {
  return LEVEL_PALETTES[(level - 1) % LEVEL_PALETTES.length];
}

function applyPalette() {
  const pal = getPalette();
  const gridEl = document.getElementById('grid');
  gridEl.style.background = pal.grid;
  gridEl.style.borderColor = pal.grid;
  document.body.style.background = pal.bg;
}

// ============================================================
// UTILITIES
// ============================================================

function neighbor(r, c, dir) {
  return { N:[r-1,c], S:[r+1,c], E:[r,c+1], W:[r,c-1] }[dir];
}

function opp(dir) { return { N:'S', S:'N', E:'W', W:'E' }[dir]; }
function dirIdx(dir) { return { N:0, S:1, E:2, W:3 }[dir]; }

function connects(pipe, dir) {
  if (!pipe) return false;
  if (pipe.id.startsWith('START_')) return pipe.emit === dir;
  if (pipe.id === 'END') return pipe.opens === dir;
  return pipe.conn[dirIdx(dir)] === 1;
}

function getOutDirs(pipe, fromDir) {
  if (pipe.id.startsWith('START_')) return [pipe.emit];
  if (pipe.id === 'END') return [];
  if (pipe.id === 'CROSS') return fromDir ? [opp(fromDir)] : [];
  return ['N','S','E','W'].filter((d, i) => pipe.conn[i] && d !== fromDir);
}

function getExitDir(pipe, fromDir) {
  return getOutDirs(pipe, fromDir)[0] || null;
}

// ============================================================
// GRID INIT
// ============================================================
function initGrid() {
  grid = Array.from({ length: ROWS }, () =>
    Array.from({ length: COLS }, () => ({ pipe: null, fromDir: null, waterFill: 0, fromDir2: null, waterFill2: 0 }))
  );
}

function placeStart() {
  const r = 1 + Math.floor(Math.random() * (ROWS - 2));
  const c = 1 + Math.floor(Math.random() * (COLS - 2));
  const emit = ['N','S','E','W'][Math.floor(Math.random() * 4)];
  grid[r][c].pipe = { id: `START_${emit}`, emit };
  startCell = { r, c };
  flowPath = [{ r, c }];
}

function placeEnd() {
  const candidates = [];
  for (let c = 1; c < COLS - 1; c++) {
    candidates.push({ r: 0,       c, opens: 'S' });
    candidates.push({ r: ROWS-1,  c, opens: 'N' });
  }
  for (let r = 1; r < ROWS - 1; r++) {
    candidates.push({ r, c: 0,      opens: 'E' });
    candidates.push({ r, c: COLS-1, opens: 'W' });
  }
  for (let i = candidates.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
  }
  for (const cand of candidates) {
    if (Math.abs(cand.r - startCell.r) + Math.abs(cand.c - startCell.c) < 4) continue;
    grid[cand.r][cand.c].pipe = { id: 'END', opens: cand.opens };
    endCell = { r: cand.r, c: cand.c };
    return;
  }
}

function placeBonusTile() {
  bonusCell = null;
  const candidates = [];
  for (let r = 1; r < ROWS - 1; r++) {
    for (let c = 1; c < COLS - 1; c++) {
      if (grid[r][c].pipe) continue;
      const dStart = Math.abs(r - startCell.r) + Math.abs(c - startCell.c);
      const dEnd   = Math.abs(r - endCell.r)   + Math.abs(c - endCell.c);
      if (dStart < 2 || dEnd < 2) continue;
      candidates.push({ r, c });
    }
  }
  if (!candidates.length) return;
  const pick = candidates[Math.floor(Math.random() * candidates.length)];
  const conn = Math.random() < 0.5 ? [0,0,1,1] : [1,1,0,0]; // H or V straight
  grid[pick.r][pick.c].pipe = { id: 'BONUS', conn };
  bonusCell = { r: pick.r, c: pick.c };
}

// ============================================================
// PIECE BAG  (2× full set of 8, shuffled — guarantees corner balance)
// ============================================================
// One set: all 4 corners + both straights + 2 crosses = 8 pieces
const BAG_SET = ['CNE','CNW','CSE','CSW','SH','SV','CROSS','CROSS'];
let pieceBag = [];

function refillBag() {
  const bag = [...BAG_SET, ...BAG_SET]; // 16 pieces — two full sets
  for (let i = bag.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [bag[i], bag[j]] = [bag[j], bag[i]];
  }
  pieceBag = bag;
}

function drawPiece() {
  if (pieceBag.length === 0) refillBag();
  return PIPES[pieceBag.pop()];
}

// ============================================================
// QUEUE
// ============================================================
function buildQueue() {
  refillBag();
  queue = Array.from({ length: 5 }, () => drawPiece());
}

function popQueue() {
  const p = queue.shift();
  queue.push(drawPiece());
  renderQueue();
  return p;
}

// ============================================================
// GAME FLOW
// ============================================================
function startGame() {
  level = 1; score = 0; lives = MAX_LIVES;
  document.getElementById('overlay').classList.remove('show');
  newLevel();
}

function newLevel() {
  stopAll();
  initGrid();
  placeStart();
  placeEnd();
  buildQueue();
  placeBonusTile();
  applyPalette();
  renderAll();
  gameState = 'placing';
  updateHUD();
  const p = levelParams(level);
  currentLevelParams = p;
  flowSpeedMult = 1;
  const speedupBtn = document.getElementById('speedup-btn');
  speedupBtn.disabled = false;
  speedupBtn.textContent = '▶▶ GO';
  countdownVal = p.flowDelay / 1000;
  timerStart = Date.now();
  updateTimerBar(1);
  startCountdown(p);
  startFaucetAnim();
  setMsg(`LEVEL ${level} — Place pipes before water flows!`);
  startMusic((level - 1) % MUSIC_THEMES.length);
}

function startCountdown(params) {
  if (countdownTimer) clearInterval(countdownTimer);
  lastCountdownInt = -1;
  countdownTimer = setInterval(() => {
    countdownVal = Math.max(0, (params.flowDelay - (Date.now() - timerStart)) / 1000);
    updateTimerBar(countdownVal / (params.flowDelay / 1000));
    const ci = Math.ceil(countdownVal);
    document.getElementById('countdown-display').textContent = ci;
    if (ci !== lastCountdownInt && ci <= 5 && ci > 0) {
      sfxCountdownTick(1 - ci / 5);
      lastCountdownInt = ci;
    }
    if (countdownVal <= 0) {
      clearInterval(countdownTimer);
      countdownTimer = null;
      beginFlow(params);
    }
  }, 100);
}

function beginFlow(params) {
  stopFaucetAnim();
  gameState = 'flowing';
  sfxFlowStart();
  setMsg('WATER IS FLOWING!');
  grid[startCell.r][startCell.c].waterFill = 1;
  renderCell(startCell.r, startCell.c);
  flowActive = true;
  firstFlowTimeout = setTimeout(() => {
    if (flowActive) startNextFlow(params);
  }, params.firstDelay);
}

function startNextFlow(params) {
  const last = flowPath[flowPath.length - 1];
  const cell = grid[last.r][last.c];
  const entryDir = (last.secondPass && cell.fromDir2) ? cell.fromDir2 : cell.fromDir;
  const outDirs = getOutDirs(cell.pipe, entryDir);

  let target = null;
  for (const dir of outDirs) {
    const [nr, nc] = neighbor(last.r, last.c, dir);
    if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
    const ncell = grid[nr][nc];
    if (!ncell.pipe) continue;
    if (!connects(ncell.pipe, opp(dir))) continue;

    if (ncell.waterFill >= 1) {
      // Allow a second perpendicular pass through CROSS
      if (ncell.pipe.id !== 'CROSS' || ncell.waterFill2 > 0) continue;
      const existingNS = ncell.fromDir === 'N' || ncell.fromDir === 'S';
      const newNS = opp(dir) === 'N' || opp(dir) === 'S';
      if (existingNS === newNS) continue; // same axis already used
      target = { r: nr, c: nc, fromDir: opp(dir), secondPass: true };
      break;
    }

    if (ncell.waterFill > 0) continue;
    target = { r: nr, c: nc, fromDir: opp(dir) };
    break;
  }

  if (!target) { endGame(); return; }

  currentFlowCell = target;
  flowProgress = 0;
  if (target.secondPass) {
    grid[target.r][target.c].fromDir2 = target.fromDir;
  } else {
    grid[target.r][target.c].fromDir = target.fromDir;
  }
  lastTime = null;
  animFrame = requestAnimationFrame(ts => animateFlowFrame(ts, params));
}

function animateFlowFrame(timestamp, params) {
  if (!flowActive) return;
  if (!lastTime) lastTime = timestamp;
  const dt = timestamp - lastTime;
  lastTime = timestamp;

  flowProgress = Math.min(1, flowProgress + dt * flowSpeedMult / params.flowInterval);
  const fc = grid[currentFlowCell.r][currentFlowCell.c];
  if (currentFlowCell.secondPass) fc.waterFill2 = flowProgress;
  else fc.waterFill = flowProgress;
  renderCell(currentFlowCell.r, currentFlowCell.c);

  if (flowProgress >= 1) {
    flowPath.push({ r: currentFlowCell.r, c: currentFlowCell.c, secondPass: currentFlowCell.secondPass });
    const filledPipe = grid[currentFlowCell.r][currentFlowCell.c].pipe;
    score++;
    sfxWaterPipe();
    if (filledPipe && filledPipe.id === 'BONUS') {
      const bonusPts = level * 5;
      score += bonusPts;
      setMsg(`★ BONUS PIPE! +${bonusPts} points`);
      sfxBonus();
    }
    updateHUD();
    if (currentFlowCell.r === endCell.r && currentFlowCell.c === endCell.c) {
      levelComplete();
      return;
    }
    currentFlowCell = null;
    startNextFlow(params);
    return;
  }
  animFrame = requestAnimationFrame(ts => animateFlowFrame(ts, params));
}

function explodeUnfilledPipes(callback) {
  const unfilled = [];
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = grid[r][c];
      if (!cell.pipe || cell.waterFill > 0) continue;
      if (cell.pipe.id.startsWith('START_') || cell.pipe.id === 'END' || cell.pipe.id === 'BONUS') continue;
      unfilled.push({ r, c });
    }
  }
  if (!unfilled.length) { callback(); return; }

  const deduction = unfilled.length;
  let frame = 0;
  const FRAMES = 14;

  function step() {
    frame++;
    for (const { r, c } of unfilled) {
      const el = document.getElementById(`cell-${r}-${c}`);
      if (!el) continue;
      const ctx = el.querySelector('canvas').getContext('2d');
      ctx.clearRect(0, 0, CELL, CELL);
      if (frame < FRAMES) {
        // Alternate flash: red-orange on odd frames, dim on even
        if (frame % 2 === 1) {
          const alpha = 1 - frame / FRAMES;
          ctx.fillStyle = `rgba(255,70,20,${alpha * 0.9})`;
          ctx.fillRect(0, 0, CELL, CELL);
          // Draw × in center
          ctx.strokeStyle = `rgba(255,220,50,${alpha})`;
          ctx.lineWidth = 3;
          const m = CELL * 0.28;
          ctx.beginPath(); ctx.moveTo(m, m); ctx.lineTo(CELL-m, CELL-m); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(CELL-m, m); ctx.lineTo(m, CELL-m); ctx.stroke();
        }
      }
      // On last frame cell stays cleared (pipe removed below)
    }
    if (frame % 2 === 1) sfxExplode();
    if (frame < FRAMES) {
      setTimeout(step, 100);
    } else {
      for (const { r, c } of unfilled) { grid[r][c].pipe = null; }
      score = Math.max(0, score - deduction);
      updateHUD();
      setMsg(`-${deduction} pt${deduction !== 1 ? 's' : ''} — ${deduction} unfilled pipe${deduction !== 1 ? 's' : ''} removed`);
      callback();
    }
  }
  step();
}

function levelComplete() {
  stopAll();
  gameState = 'over';
  sfxLevelComplete();
  explodeUnfilledPipes(() => {
    const bonus = level * 10;
    score += bonus;
    if (score > best) { best = score; localStorage.setItem('pm_best', best); }
    updateHUD();
    level++;
    showOverlay(`LEVEL ${level - 1} COMPLETE!`, `Water reached the target! +${bonus} bonus`, `Score: ${score}  |  Best: ${best}`, 'NEXT LEVEL', 'next');
  });
}

function endGame() {
  stopAll();
  gameState = 'over';
  lives--;
  if (score > best) { best = score; localStorage.setItem('pm_best', best); }
  updateHUD();
  if (lives <= 0) {
    pendingScore = { score, level };
    stopMusic();
    sfxGameOver();
    showOverlay('GAME OVER', 'No lives remaining!', `Score: ${score}  |  Best: ${best}`, 'PLAY AGAIN', 'gameover');
  } else {
    sfxLifeLost();
    const lifeWord = lives === 1 ? 'life' : 'lives';
    showOverlay('LIFE LOST', `Water ran dry! ${lives} ${lifeWord} remaining.`, `Score: ${score}  |  Best: ${best}`, 'RETRY', 'retry');
  }
}

function stopAll() {
  flowActive = false;
  if (animFrame) { cancelAnimationFrame(animFrame); animFrame = null; }
  if (firstFlowTimeout) { clearTimeout(firstFlowTimeout); firstFlowTimeout = null; }
  if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
  stopFaucetAnim();
}

// ============================================================
// PLACE PIPE
// ============================================================
function placePipe(r, c) {
  if (gameState !== 'placing' && gameState !== 'flowing') return;
  const cell = grid[r][c];
  if (!cell) return;
  if (cell.pipe) return;
  if (cell.waterFill > 0) return;
  cell.pipe = queue[0];
  sfxPlace();
  popQueue();
  renderCell(r, c);
}

// ============================================================
// HUD
// ============================================================
function updateHUD() {
  document.getElementById('score-display').textContent = score;
  document.getElementById('best-display').textContent = best;
  document.getElementById('level-display').textContent = level;
  const hearts = '♥'.repeat(Math.max(0, lives)) + '♡'.repeat(Math.max(0, MAX_LIVES - lives));
  document.getElementById('lives-display').textContent = hearts;
}

function updateTimerBar(pct) {
  document.getElementById('timer-bar').style.width = (pct * 100) + '%';
}

function setMsg(m) { document.getElementById('msg').textContent = m; }

function showOverlay(title, msg, sub, btn, action) {
  overlayAction = action;
  document.getElementById('overlay-title').textContent = title;
  document.getElementById('overlay-msg').textContent = msg;
  const sc = document.getElementById('overlay-score');
  sc.style.display = sub ? 'block' : 'none';
  sc.textContent = sub || '';
  document.getElementById('overlay-btn').textContent = btn;

  const initSection = document.getElementById('initials-section');
  if (pendingScore && qualifiesForBoard(pendingScore.score)) {
    initSection.style.display = 'flex';
    const inp = document.getElementById('initials-input');
    inp.value = '';
    setTimeout(() => inp.focus(), 80);
  } else {
    initSection.style.display = 'none';
  }
  renderLeaderboard(pendingScore ? pendingScore.score : null);

  const isWarning = (action === 'retry' || action === 'gameover');
  const accent = isWarning ? '#e74c3c' : '#f0a500';
  const box = document.getElementById('overlay-box');
  box.classList.remove('is-title');
  box.style.borderColor = accent;
  document.getElementById('overlay-title').style.color = accent;
  document.getElementById('overlay-btn').style.background = accent;
  document.getElementById('overlay').classList.add('show');
}

// ============================================================
// FAUCET ANIMATION
// ============================================================
function startFaucetAnim() {
  stopFaucetAnim();
  faucetPulse = 0;
  faucetAnimTimer = setInterval(() => {
    faucetPulse = (faucetPulse + 1) % 16;
    if (startCell) renderCell(startCell.r, startCell.c);
  }, 80);
}
function stopFaucetAnim() {
  if (faucetAnimTimer) { clearInterval(faucetAnimTimer); faucetAnimTimer = null; }
}

// ============================================================
// RENDERING
// ============================================================
function renderAll() { renderGrid(); renderQueue(); }

function renderGrid() {
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      renderCell(r, c);
}

function renderCell(r, c) {
  const el = document.getElementById(`cell-${r}-${c}`);
  if (!el) return;
  const ctx = el.querySelector('canvas').getContext('2d');
  ctx.clearRect(0, 0, CELL, CELL);
  const { pipe, waterFill, fromDir, waterFill2, fromDir2 } = grid[r][c];
  if (!pipe) return;
  if (pipe.id.startsWith('START_')) { drawFaucet(ctx, pipe.emit, waterFill, CELL); return; }
  if (pipe.id === 'END')            { drawEndTile(ctx, pipe.opens, waterFill, CELL); return; }
  drawPipe(ctx, pipe, waterFill, fromDir, CELL, waterFill2, fromDir2);
}

function renderQueue() {
  const cells = document.querySelectorAll('.queue-cell');
  cells.forEach((cell, i) => {
    const ctx = cell.querySelector('canvas').getContext('2d');
    ctx.clearRect(0, 0, 54, 54);
    if (queue[i]) drawPipe(ctx, queue[i], 0, null, 54);
  });
}

// ============================================================
// AUDIO  (Web Audio API — all synthesised, no files)
// ============================================================
let audioCtx = null;

function getAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function beep(freq, type, vol, attack, sustain, release, delay = 0) {
  const ctx = getAudio();
  const t = ctx.currentTime + delay;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(0.001, t);
  gain.gain.linearRampToValueAtTime(vol, t + attack);
  gain.gain.setValueAtTime(vol, t + attack + sustain);
  gain.gain.exponentialRampToValueAtTime(0.001, t + attack + sustain + release);
  osc.connect(gain); gain.connect(ctx.destination);
  osc.start(t); osc.stop(t + attack + sustain + release + 0.05);
}

function noise(durationSec, vol, filterFreq, filterType = 'bandpass') {
  const ctx = getAudio();
  const buf = ctx.createBuffer(1, ctx.sampleRate * durationSec, ctx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  const src = ctx.createBufferSource(); src.buffer = buf;
  const filt = ctx.createBiquadFilter(); filt.type = filterType; filt.frequency.value = filterFreq;
  const gain = ctx.createGain();
  gain.gain.setValueAtTime(vol, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + durationSec);
  src.connect(filt); filt.connect(gain); gain.connect(ctx.destination);
  src.start(); src.stop(ctx.currentTime + durationSec + 0.05);
}

function sfxPlace() {
  beep(280, 'square', 0.10, 0.005, 0, 0.07);
  beep(140, 'square', 0.06, 0.005, 0, 0.05, 0.01);
}

function sfxWaterPipe() {
  const ctx = getAudio();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  const f = 180 + Math.random() * 80;
  osc.type = 'sine';
  osc.frequency.setValueAtTime(f * 1.4, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(f * 0.65, ctx.currentTime + 0.15);
  gain.gain.setValueAtTime(0.13, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
  osc.connect(gain); gain.connect(ctx.destination);
  osc.start(); osc.stop(ctx.currentTime + 0.22);
}

function sfxBonus() {
  [784, 988, 1175, 1568].forEach((f, i) => beep(f, 'triangle', 0.22, 0.01, 0.06, 0.14, i * 0.08));
}

function sfxFlowStart() {
  const ctx = getAudio();
  const buf = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  const src = ctx.createBufferSource(); src.buffer = buf;
  const filt = ctx.createBiquadFilter(); filt.type = 'bandpass'; filt.Q.value = 1.5;
  filt.frequency.setValueAtTime(150, ctx.currentTime);
  filt.frequency.linearRampToValueAtTime(900, ctx.currentTime + 0.45);
  const gain = ctx.createGain();
  gain.gain.setValueAtTime(0.001, ctx.currentTime);
  gain.gain.linearRampToValueAtTime(0.35, ctx.currentTime + 0.08);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.45);
  src.connect(filt); filt.connect(gain); gain.connect(ctx.destination);
  src.start(); src.stop(ctx.currentTime + 0.5);
}

function sfxLevelComplete() {
  [261, 329, 392, 523, 659].forEach((f, i) => beep(f, 'triangle', 0.28, 0.01, 0.1, 0.18, i * 0.11));
}

function sfxLifeLost() {
  [349, 277, 220].forEach((f, i) => beep(f, 'sawtooth', 0.22, 0.01, 0.12, 0.22, i * 0.2));
}

function sfxGameOver() {
  [330, 277, 220, 175, 147].forEach((f, i) => beep(f, 'sawtooth', 0.24, 0.02, 0.14, 0.28, i * 0.22));
}

function sfxExplode() {
  noise(0.12, 0.28, 700, 'highpass');
  beep(160, 'square', 0.14, 0.005, 0, 0.1);
}

function sfxCountdownTick(urgency) {
  beep(440 + urgency * 440, 'square', 0.05 + urgency * 0.05, 0.004, 0, 0.04);
}

let lastCountdownInt = -1;

// ============================================================
// DRAWING — PIPE
// ============================================================
function drawPipe(ctx, pipe, waterFill, fromDir, S, waterFill2 = 0, fromDir2 = null) {
  const cx = S / 2, cy = S / 2, PW = S * PW_RATIO;
  const pal = getPalette();
  const isBonus = pipe.id === 'BONUS';
  const pC = isBonus ? '#d4a010' : pal.pipe;
  const pB = isBonus ? '#7a5800' : pal.pipeB;

  function fr(x, y, w, h, col) {
    if (w <= 0 || h <= 0) return;
    ctx.fillStyle = col; ctx.fillRect(x, y, w, h);
  }

  const conn = pipe.conn;
  if (conn[0]) { fr(cx-PW/2-BW, 0,          PW+BW*2, cy+PW/2+BW,         pB); fr(cx-PW/2, 0,        PW, cy+PW/2,    pC); }
  if (conn[1]) { fr(cx-PW/2-BW, cy-PW/2-BW, PW+BW*2, S-(cy-PW/2-BW),     pB); fr(cx-PW/2, cy-PW/2,  PW, S-cy+PW/2,  pC); }
  if (conn[2]) { fr(cx-PW/2-BW, cy-PW/2-BW, S-(cx-PW/2-BW), PW+BW*2,     pB); fr(cx-PW/2, cy-PW/2,  S-cx+PW/2, PW, pC); }
  if (conn[3]) { fr(0, cy-PW/2-BW, cx+PW/2+BW, PW+BW*2,                   pB); fr(0, cy-PW/2, cx+PW/2, PW,         pC); }
  fr(cx-PW/2-BW, cy-PW/2-BW, PW+BW*2, PW+BW*2, pB);
  fr(cx-PW/2,    cy-PW/2,    PW,      PW,      pC);

  if (waterFill > 0) {
    const wC = pal.water, wB = pal.waterB;
    if (waterFill >= 1) {
      const wConn = (pipe.id === 'CROSS' && fromDir)
        ? ['N','S','E','W'].map(d => (d === fromDir || d === opp(fromDir)) ? 1 : 0)
        : conn;
      if (wConn[0]) { fr(cx-PW/2-BW, 0,          PW+BW*2, cy+PW/2+BW,         wB); fr(cx-PW/2, 0,        PW, cy+PW/2,    wC); }
      if (wConn[1]) { fr(cx-PW/2-BW, cy-PW/2-BW, PW+BW*2, S-(cy-PW/2-BW),     wB); fr(cx-PW/2, cy-PW/2,  PW, S-cy+PW/2,  wC); }
      if (wConn[2]) { fr(cx-PW/2-BW, cy-PW/2-BW, S-(cx-PW/2-BW), PW+BW*2,     wB); fr(cx-PW/2, cy-PW/2,  S-cx+PW/2, PW, wC); }
      if (wConn[3]) { fr(0, cy-PW/2-BW, cx+PW/2+BW, PW+BW*2,                   wB); fr(0, cy-PW/2, cx+PW/2, PW,         wC); }
      fr(cx-PW/2-BW, cy-PW/2-BW, PW+BW*2, PW+BW*2, wB);
      fr(cx-PW/2,    cy-PW/2,    PW,      PW,       wC);
    } else {
      drawPartialWater(ctx, pipe, fromDir, waterFill, S, cx, cy, PW);
    }
  }

  // Second axis fill for CROSS (perpendicular pass)
  if (pipe.id === 'CROSS' && waterFill2 > 0) {
    const wC = getPalette().water, wB = getPalette().waterB;
    function fr2(x, y, w, h, col) { if (w <= 0 || h <= 0) return; ctx.fillStyle = col; ctx.fillRect(x, y, w, h); }
    if (waterFill2 >= 1) {
      const wConn2 = fromDir2 ? ['N','S','E','W'].map(d => (d === fromDir2 || d === opp(fromDir2)) ? 1 : 0) : [0,0,0,0];
      if (wConn2[0]) { fr2(cx-PW/2-BW, 0,          PW+BW*2, cy+PW/2+BW,         wB); fr2(cx-PW/2, 0,        PW, cy+PW/2,    wC); }
      if (wConn2[1]) { fr2(cx-PW/2-BW, cy-PW/2-BW, PW+BW*2, S-(cy-PW/2-BW),     wB); fr2(cx-PW/2, cy-PW/2,  PW, S-cy+PW/2,  wC); }
      if (wConn2[2]) { fr2(cx-PW/2-BW, cy-PW/2-BW, S-(cx-PW/2-BW), PW+BW*2,     wB); fr2(cx-PW/2, cy-PW/2,  S-cx+PW/2, PW, wC); }
      if (wConn2[3]) { fr2(0, cy-PW/2-BW, cx+PW/2+BW, PW+BW*2,                   wB); fr2(0, cy-PW/2, cx+PW/2, PW,         wC); }
      fr2(cx-PW/2-BW, cy-PW/2-BW, PW+BW*2, PW+BW*2, wB);
      fr2(cx-PW/2,    cy-PW/2,    PW,      PW,       wC);
    } else {
      drawPartialWater(ctx, pipe, fromDir2, waterFill2, S, cx, cy, PW);
    }
  }

  // Bonus star marker (shown when not yet water-filled)
  if (isBonus && waterFill < 1) {
    drawStar(ctx, cx, cy, S * 0.13, S * 0.055, 5, '#ffe066', '#9a7000');
  }
}

// ============================================================
// DRAWING — PARTIAL WATER FILL
// ============================================================
function drawPartialWater(ctx, pipe, fromDir, p, S, cx, cy, PW) {
  if (!fromDir || p <= 0) return;
  const exitDir = getExitDir(pipe, fromDir);
  const wC = getPalette().water;

  function entry(dir, ap) {
    if (ap <= 0) return;
    ctx.fillStyle = wC;
    if (dir === 'W') ctx.fillRect(0,              cy-PW/2, Math.max(0,(cx+PW/2)*ap),    PW);
    if (dir === 'E') ctx.fillRect(S-(cx+PW/2)*ap, cy-PW/2, Math.max(0,(cx+PW/2)*ap),    PW);
    if (dir === 'N') ctx.fillRect(cx-PW/2, 0,              PW, Math.max(0,(cy+PW/2)*ap));
    if (dir === 'S') ctx.fillRect(cx-PW/2, S-(cy+PW/2)*ap, PW, Math.max(0,(cy+PW/2)*ap));
  }

  function exit_(dir, ap) {
    if (ap <= 0 || !dir) return;
    ctx.fillStyle = wC;
    if (dir === 'E') ctx.fillRect(cx+PW/2, cy-PW/2, Math.max(0,(S-cx-PW/2)*ap),   PW);
    if (dir === 'W') ctx.fillRect(Math.max(0,cx-PW/2-(cx-PW/2)*ap), cy-PW/2, Math.max(0,(cx-PW/2)*ap), PW);
    if (dir === 'S') ctx.fillRect(cx-PW/2, cy+PW/2, PW, Math.max(0,(S-cy-PW/2)*ap));
    if (dir === 'N') ctx.fillRect(cx-PW/2, Math.max(0,cy-PW/2-(cy-PW/2)*ap), PW, Math.max(0,(cy-PW/2)*ap));
  }

  if (p <= 0.5) {
    entry(fromDir, p * 2);
  } else {
    entry(fromDir, 1);
    exit_(exitDir, (p - 0.5) * 2);
  }
}

// ============================================================
// DRAWING — FAUCET (START TILE)
// ============================================================
function drawFaucet(ctx, emit, waterFill, S) {
  const cx = S/2, cy = S/2, PW = S * PW_RATIO;
  const rot = { E:0, S:Math.PI/2, W:Math.PI, N:-Math.PI/2 };
  const filled = waterFill >= 1;
  const pal = getPalette();
  const pC = filled ? pal.water : pal.pipe;
  const pB = filled ? pal.waterB : pal.pipeB;

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rot[emit] || 0);

  function fr(x, y, w, h, col) { if(w<=0||h<=0) return; ctx.fillStyle=col; ctx.fillRect(x,y,w,h); }

  fr(-PW/2-BW, -PW/2-BW, S/2+PW/2+BW+4, PW+BW*2, pB);
  fr(-PW/2,    -PW/2,    S/2+PW/2,       PW,      pC);

  fr(-S/2-BW, -PW/2-BW, BW*4, PW+BW*2, pB);
  fr(-S/2,    -PW/2,    BW*2, PW,      '#0d1a30');

  const bx=-S*0.2, bw=S*0.36, bh=S*0.44;
  fr(bx-2, -bh/2-2, bw+4, bh+4, '#7a5000');
  fr(bx,   -bh/2,   bw,   bh,   '#c0850a');
  ctx.fillStyle='rgba(255,220,80,0.2)';
  ctx.fillRect(bx+3, -bh/2+3, bw*0.45, bh*0.35);

  const hcx = bx + bw/2;
  const sty = -bh/2 - S*0.18, sth = S*0.18, stw = S*0.09;
  const barw = S*0.36, barh = S*0.09;
  fr(hcx-stw/2-1, sty-1,       stw+2, sth+2, '#7a5000');
  fr(hcx-barw/2-1,sty-barh-1,  barw+2,barh+2,'#7a5000');
  fr(hcx-stw/2,   sty,         stw,   sth,   '#d4900f');
  fr(hcx-barw/2,  sty-barh,    barw,  barh,  '#e8a820');

  fr(S/2-5, -PW/2-4, 6, PW+8, '#7a5000');
  fr(S/2-4, -PW/2-3, 4, PW+6, '#c0850a');
  fr(S/2-2, -PW/2+3, 3, PW-6, filled ? '#4fffb0' : '#0d1a30');

  if (!filled) {
    const t = faucetPulse / 16;
    const alpha = 0.45 + 0.55 * Math.sin(t * Math.PI * 2);
    const drift = (t * S * 0.22) % (S * 0.22);
    const ax = bx + bw * 0.6 + drift;
    const aw = S * 0.11, ah = S * 0.13;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#ffe066';
    ctx.beginPath();
    ctx.moveTo(ax,       -ah/2);
    ctx.lineTo(ax + aw,  0);
    ctx.lineTo(ax,        ah/2);
    ctx.lineTo(ax + aw*0.5, 0);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

// ============================================================
// DRAWING — END TILE (TARGET)
// ============================================================
function drawEndTile(ctx, opens, waterFill, S) {
  const cx = S/2, cy = S/2, PW = S * PW_RATIO;
  const filled = waterFill >= 1;
  const pal = getPalette();
  const pC = filled ? pal.water  : C_END;
  const pB = filled ? pal.waterB : C_END_B;

  function fr(x, y, w, h, col) { if(w<=0||h<=0) return; ctx.fillStyle=col; ctx.fillRect(x,y,w,h); }

  if (opens === 'N') { fr(cx-PW/2-BW, 0,          PW+BW*2, cy+PW/2+BW,         pB); fr(cx-PW/2, 0,        PW, cy+PW/2,    pC); }
  if (opens === 'S') { fr(cx-PW/2-BW, cy-PW/2-BW, PW+BW*2, S-(cy-PW/2-BW),     pB); fr(cx-PW/2, cy-PW/2,  PW, S-cy+PW/2,  pC); }
  if (opens === 'E') { fr(cx-PW/2-BW, cy-PW/2-BW, S-(cx-PW/2-BW), PW+BW*2,     pB); fr(cx-PW/2, cy-PW/2,  S-cx+PW/2, PW, pC); }
  if (opens === 'W') { fr(0, cy-PW/2-BW, cx+PW/2+BW, PW+BW*2,                   pB); fr(0, cy-PW/2, cx+PW/2, PW,         pC); }

  fr(cx-PW/2-BW, cy-PW/2-BW, PW+BW*2, PW+BW*2, pB);
  fr(cx-PW/2,    cy-PW/2,    PW,      PW,       pC);

  if (waterFill > 0 && waterFill < 1) {
    ctx.fillStyle = pal.water;
    const p = waterFill;
    if (opens === 'N') ctx.fillRect(cx-PW/2, 0, PW, cy * p);
    if (opens === 'S') ctx.fillRect(cx-PW/2, S - S*p, PW, S*p);
    if (opens === 'E') ctx.fillRect(S - S*p, cy-PW/2, S*p, PW);
    if (opens === 'W') ctx.fillRect(0, cy-PW/2, S*p, PW);
  }

  const starR = filled ? S * 0.19 : S * 0.17;
  const starInner = starR * 0.45;
  const starFill   = filled ? pal.water  : '#ffe066';
  const starStroke = filled ? pal.waterB : '#9a7000';
  drawStar(ctx, cx, cy, starR, starInner, 5, starFill, starStroke);
}

function drawStar(ctx, cx, cy, outerR, innerR, pts, fill, stroke) {
  ctx.beginPath();
  for (let i = 0; i < pts * 2; i++) {
    const r = i % 2 === 0 ? outerR : innerR;
    const a = i * Math.PI / pts - Math.PI / 2;
    const x = cx + r * Math.cos(a), y = cy + r * Math.sin(a);
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.fillStyle = fill; ctx.fill();
  ctx.strokeStyle = stroke; ctx.lineWidth = 2; ctx.stroke();
}

// ============================================================
// MUSIC ENGINE  (7 level themes — chiptune, Web Audio lookahead)
// ============================================================
let musicGain = null, musicScheduler = null, musicMuted = false;
let currentMelody = null, currentBass = null, M16 = 60/160/4;
let _snareBuffer = null, _hatBuffer = null;
let melodyPtr = 0, nextMelodyTime = 0;
let bassPtr   = 0, nextBassTime   = 0;
let drumPtr   = 0, nextDrumTime   = 0;

const MAHEAD = 0.2, MINT = 25;

// Note frequencies (Hz) — all keys used across 7 themes
const _F3=174.61,_G3=196.00,_A3=220.00,_Bb3=233.08,_B3=246.94;
const _C4=261.63,_Cs4=277.18,_D4=293.66,_E4=329.63,_F4=349.23,_Fs4=369.99,_G4=392.00,_Bb4=466.16;
const _A4=440.00,_B4=493.88,_C5=523.25,_Cs5=554.37,_D5=587.33,_E5=659.25,_F5=698.46,_Fs5=739.99,_G5=783.99,_Gs5=830.61;
const _A5=880.00,_B5=987.77;

// Drum pattern — 1-bar loop: kick on 1&3, snare on 2&4, hat every 8th
const DRUM_PAT = [
  ['kick','hat'],[], ['hat'],[],
  ['snare','hat'],[], ['hat'],[],
  ['kick','hat'],[], ['hat'],[],
  ['snare','hat'],[], ['hat'],[],
];

// 7 level themes — each matches its colour palette
// melody: 4-bar loop (64 × 16ths) [freq|0, dur_16ths]
// bass:   2-bar loop (32 × 16ths)
const MUSIC_THEMES = [
  // 0 — A major 160 BPM — cool blue/green (level 1)
  { bpm:160, melody:[
    [_E5,2],[0,1],[_E5,1],[_Cs5,2],[0,2],[_A4,2],[0,2],[_E5,2],[_A5,2],
    [_B5,2],[0,1],[_A5,1],[_Fs5,2],[_E5,2],[0,4],[_Cs5,2],[0,2],
    [_Gs5,1],[_Fs5,1],[_E5,2],[_Cs5,2],[0,1],[_B4,1],[_A4,4],[0,4],
    [_E5,2],[_Fs5,2],[_Gs5,2],[_A5,4],[0,2],[_E5,2],[0,2],
  ], bass:[
    [_A3,4],[_E4,4],[_A3,4],[_E4,4],
    [_D4,4],[_A3,4],[_Cs4,4],[_E4,4],
  ]},
  // 1 — D major 168 BPM — syncopated purple/orange (level 2)
  { bpm:168, melody:[
    [_D5,2],[0,1],[_D5,1],[_B4,2],[0,2],[_G4,2],[0,2],[_A4,2],[_D5,2],
    [_Fs5,2],[0,1],[_D5,1],[_B4,2],[_A4,2],[0,4],[_Fs4,2],[0,2],
    [_G5,1],[_Fs5,1],[_E5,2],[_D5,2],[0,1],[_B4,1],[_G4,4],[0,4],
    [_A4,2],[_B4,2],[_Cs5,2],[_D5,4],[0,2],[_A4,2],[0,2],
  ], bass:[
    [_D4,4],[_A4,4],[_D4,4],[_A4,4],
    [_G4,4],[_D4,4],[_Fs4,4],[_A4,4],
  ]},
  // 2 — E minor 152 BPM — dark dramatic red/blue (level 3)
  { bpm:152, melody:[
    [_E5,2],[0,2],[_D5,2],[_B4,2],[_G4,2],[0,2],[_B4,2],[_E5,2],
    [_G5,2],[0,2],[_Fs5,2],[_E5,2],[0,2],[_D5,2],[_B4,4],
    [_E5,2],[_D5,2],[_C5,2],[_B4,4],[0,2],[_E4,2],[0,2],
    [_G5,4],[0,2],[_E5,2],[_D5,2],[_B4,2],[0,2],[_B4,2],
  ], bass:[
    [_E4,4],[_B3,4],[_E4,4],[_B3,4],
    [_G4,4],[_E4,4],[_D4,4],[_B3,4],
  ]},
  // 3 — C major 172 BPM — bright cheerful teal/gold (level 4)
  { bpm:172, melody:[
    [_E5,2],[0,1],[_E5,1],[_C5,2],[0,4],[_G4,2],[0,2],[_C5,2],
    [_G5,2],[0,1],[_G5,1],[_E5,2],[_C5,2],[0,4],[_A4,2],[0,2],
    [_F4,1],[_G4,1],[_A4,2],[_C5,2],[0,1],[_E4,1],[_G4,4],[0,4],
    [_C5,2],[_D5,2],[_E5,2],[_G5,4],[0,2],[_E5,2],[0,2],
  ], bass:[
    [_C4,4],[_G4,4],[_C4,4],[_G4,4],
    [_F4,4],[_C4,4],[_E4,4],[_G4,4],
  ]},
  // 4 — G major 176 BPM — driving energetic orange/purple (level 5)
  { bpm:176, melody:[
    [_D5,2],[0,1],[_D5,1],[_B4,2],[0,2],[_G4,2],[0,2],[_D5,2],[_G5,2],
    [_A4,2],[0,1],[_G4,1],[_Fs4,2],[_G4,2],[0,4],[_E4,2],[0,2],
    [_B4,1],[_A4,1],[_G4,2],[_E4,2],[0,1],[_D4,1],[_G3,4],[0,4],
    [_G4,2],[_A4,2],[_B4,2],[_D5,4],[0,2],[_B4,2],[0,2],
  ], bass:[
    [_G3,4],[_D4,4],[_G3,4],[_D4,4],
    [_C4,4],[_G3,4],[_B3,4],[_D4,4],
  ]},
  // 5 — B minor 164 BPM — mysterious blue/red (level 6)
  { bpm:164, melody:[
    [_Fs5,2],[0,1],[_Fs5,1],[_D5,2],[0,2],[_B4,2],[0,2],[_Fs5,2],[_B5,2],
    [_A5,2],[0,1],[_Fs5,1],[_E5,2],[_D5,2],[0,4],[_B4,2],[0,2],
    [_E5,1],[_D5,1],[_Cs5,2],[_B4,2],[0,1],[_A4,1],[_Fs4,4],[0,4],
    [_B4,2],[_Cs5,2],[_D5,2],[_Fs5,4],[0,2],[_D5,2],[0,2],
  ], bass:[
    [_B3,4],[_Fs4,4],[_B3,4],[_Fs4,4],
    [_E4,4],[_B3,4],[_D4,4],[_Fs4,4],
  ]},
  // 6 — F major 156 BPM — warm flowing green/orange (level 7)
  { bpm:156, melody:[
    [_C5,2],[0,1],[_C5,1],[_A4,2],[0,2],[_F4,2],[0,2],[_C5,2],[_F5,2],
    [_G5,2],[0,1],[_F5,1],[_D5,2],[_C5,2],[0,4],[_A4,2],[0,2],
    [_Bb4,1],[_A4,1],[_G4,2],[_E4,2],[0,1],[_D4,1],[_C4,4],[0,4],
    [_F4,2],[_G4,2],[_A4,2],[_C5,4],[0,2],[_A4,2],[0,2],
  ], bass:[
    [_F3,4],[_C4,4],[_F3,4],[_C4,4],
    [_Bb3,4],[_F3,4],[_A3,4],[_C4,4],
  ]},
];

function getMusicGain() {
  const ctx = getAudio();
  if (!musicGain) {
    musicGain = ctx.createGain();
    musicGain.gain.value = musicMuted ? 0 : 0.30;
    musicGain.connect(ctx.destination);
  }
  return musicGain;
}

function getSnareBuffer() {
  const ctx = getAudio();
  if (!_snareBuffer) {
    _snareBuffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate * 0.12), ctx.sampleRate);
    const d = _snareBuffer.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  }
  return _snareBuffer;
}

function getHatBuffer() {
  const ctx = getAudio();
  if (!_hatBuffer) {
    _hatBuffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate * 0.04), ctx.sampleRate);
    const d = _hatBuffer.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  }
  return _hatBuffer;
}

function schedMelNote(freq, t, dur16) {
  if (!freq) return;
  const ctx = getAudio(); const mg = getMusicGain();
  const dur = dur16 * M16;
  const osc = ctx.createOscillator(); const g = ctx.createGain();
  osc.type = 'square'; osc.frequency.value = freq;
  g.gain.setValueAtTime(0.001, t);
  g.gain.linearRampToValueAtTime(0.20, t + 0.005);
  g.gain.setValueAtTime(0.13, t + 0.015);
  g.gain.setValueAtTime(0.13, t + Math.max(dur * 0.70, dur - 0.03));
  g.gain.exponentialRampToValueAtTime(0.001, t + dur * 0.92);
  osc.connect(g); g.connect(mg);
  osc.start(t); osc.stop(t + dur + 0.02);
}

function schedBassNote(freq, t, dur16) {
  if (!freq) return;
  const ctx = getAudio(); const mg = getMusicGain();
  const dur = dur16 * M16;
  const osc = ctx.createOscillator(); const g = ctx.createGain();
  osc.type = 'triangle'; osc.frequency.value = freq;
  g.gain.setValueAtTime(0.001, t);
  g.gain.linearRampToValueAtTime(0.28, t + 0.01);
  g.gain.setValueAtTime(0.28, t + dur * 0.55);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur * 0.82);
  osc.connect(g); g.connect(mg);
  osc.start(t); osc.stop(t + dur + 0.02);
}

function schedDrum(t, type) {
  const ctx = getAudio(); const mg = getMusicGain();
  if (type === 'kick') {
    const osc = ctx.createOscillator(); const g = ctx.createGain();
    osc.frequency.setValueAtTime(160, t);
    osc.frequency.exponentialRampToValueAtTime(42, t + 0.13);
    g.gain.setValueAtTime(0.55, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
    osc.connect(g); g.connect(mg);
    osc.start(t); osc.stop(t + 0.22);
  } else if (type === 'snare') {
    const src = ctx.createBufferSource(); src.buffer = getSnareBuffer();
    const filt = ctx.createBiquadFilter(); filt.type = 'highpass'; filt.frequency.value = 1200;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.32, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.09);
    src.connect(filt); filt.connect(g); g.connect(mg);
    src.start(t); src.stop(t + 0.12);
  } else if (type === 'hat') {
    const src = ctx.createBufferSource(); src.buffer = getHatBuffer();
    const filt = ctx.createBiquadFilter(); filt.type = 'highpass'; filt.frequency.value = 7000;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.09, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.035);
    src.connect(filt); filt.connect(g); g.connect(mg);
    src.start(t); src.stop(t + 0.04);
  }
}

function musicSchedule() {
  if (!musicGain || !currentMelody) return;
  const ctx = getAudio();
  const now = ctx.currentTime;
  while (nextMelodyTime < now + MAHEAD) {
    const [f, d] = currentMelody[melodyPtr];
    schedMelNote(f, nextMelodyTime, d);
    nextMelodyTime += d * M16;
    melodyPtr = (melodyPtr + 1) % currentMelody.length;
  }
  while (nextBassTime < now + MAHEAD) {
    const [f, d] = currentBass[bassPtr];
    schedBassNote(f, nextBassTime, d);
    nextBassTime += d * M16;
    bassPtr = (bassPtr + 1) % currentBass.length;
  }
  while (nextDrumTime < now + MAHEAD) {
    const hits = DRUM_PAT[drumPtr];
    hits.forEach(h => schedDrum(nextDrumTime, h));
    nextDrumTime += M16;
    drumPtr = (drumPtr + 1) % DRUM_PAT.length;
  }
}

function startMusic(themeIdx) {
  if (musicScheduler) { clearInterval(musicScheduler); musicScheduler = null; }
  const theme = MUSIC_THEMES[themeIdx % MUSIC_THEMES.length];
  M16 = 60 / theme.bpm / 4;
  currentMelody = theme.melody;
  currentBass   = theme.bass;
  getMusicGain();
  const ctx = getAudio();
  const now = ctx.currentTime;
  musicGain.gain.cancelScheduledValues(now);
  musicGain.gain.setValueAtTime(musicMuted ? 0 : 0.30, now);
  melodyPtr = 0; nextMelodyTime = now + 0.1;
  bassPtr   = 0; nextBassTime   = now + 0.1;
  drumPtr   = 0; nextDrumTime   = now + 0.1;
  musicScheduler = setInterval(musicSchedule, MINT);
  musicSchedule();
}

function stopMusic() {
  if (musicScheduler) { clearInterval(musicScheduler); musicScheduler = null; }
  if (musicGain && audioCtx) {
    const now = audioCtx.currentTime;
    musicGain.gain.cancelScheduledValues(now);
    musicGain.gain.setValueAtTime(musicGain.gain.value, now);
    musicGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
  }
}

function toggleMusic() {
  musicMuted = !musicMuted;
  if (musicGain && audioCtx) {
    const now = audioCtx.currentTime;
    musicGain.gain.cancelScheduledValues(now);
    musicGain.gain.setValueAtTime(musicGain.gain.value, now);
    musicGain.gain.linearRampToValueAtTime(musicMuted ? 0 : 0.30, now + 0.05);
  }
  document.getElementById('music-btn').textContent = musicMuted ? '♩' : '♪';
  document.getElementById('music-btn').classList.toggle('muted', musicMuted);
}

// ============================================================
// DOM SETUP
// ============================================================
function buildDOM() {
  const gridEl = document.getElementById('grid');
  gridEl.innerHTML = '';
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.id = `cell-${r}-${c}`;
      const canvas = document.createElement('canvas');
      canvas.width = CELL; canvas.height = CELL;
      cell.appendChild(canvas);
      cell.addEventListener('click', () => placePipe(r, c));
      gridEl.appendChild(cell);
    }
  }

  const panel = document.getElementById('queue-panel');
  panel.innerHTML = '<h3>NEXT</h3>';
  for (let i = 0; i < 5; i++) {
    const cell = document.createElement('div');
    cell.className = 'queue-cell' + (i === 0 ? ' next' : '');
    const canvas = document.createElement('canvas');
    canvas.width = 54; canvas.height = 54;
    cell.appendChild(canvas);
    panel.appendChild(cell);
  }
}

// ============================================================
// OVERLAY BUTTON
// ============================================================
document.getElementById('overlay-btn').addEventListener('click', () => {
  if (pendingScore) {
    const raw = document.getElementById('initials-input').value;
    const initials = raw.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 3).padEnd(3, '_');
    addHighScore(initials, pendingScore.score, pendingScore.level);
    pendingScore = null;
  }
  document.getElementById('overlay').classList.remove('show');
  if (overlayAction === 'next' || overlayAction === 'retry') newLevel();
  else startGame();
});

document.getElementById('initials-input').addEventListener('input', function() {
  this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 3);
});
document.getElementById('initials-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') document.getElementById('overlay-btn').click();
});

function speedUp() {
  if (gameState !== 'placing' && gameState !== 'flowing') return;
  const btn = document.getElementById('speedup-btn');
  btn.disabled = true;
  flowSpeedMult = 4;
  if (gameState === 'placing') {
    if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
    updateTimerBar(0);
    document.getElementById('countdown-display').textContent = '0';
    beginFlow({ ...currentLevelParams, firstDelay: 150 });
  }
  setMsg('⚡ TURBO FLOW!');
}

document.getElementById('speedup-btn').addEventListener('click', speedUp);
document.addEventListener('keydown', e => {
  if (e.code === 'Space' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
    e.preventDefault();
    speedUp();
  }
});

document.getElementById('music-btn').addEventListener('click', toggleMusic);

// ============================================================
// BOOT
// ============================================================
buildDOM();
updateHUD();
renderLeaderboard(null);
</script>
</body>
</html>
